# Memory Layers

RAE implements a **4-layer cognitive memory architecture** inspired by human memory systems. Each layer serves a distinct purpose in how agents store, process, and recall information.

## Overview

```
┌─────────────────────────────────────────────────────────┐
│  EPISODIC MEMORY (EM)                                   │
│  Raw events, observations, conversations                │
│  "User fixed bug in auth.py on Jan 5"                  │
└──────────────────┬──────────────────────────────────────┘
                   │ Reflection Engine
                   ▼
┌─────────────────────────────────────────────────────────┐
│  WORKING MEMORY (WM)                                    │
│  Active context for current task                        │
│  "Currently debugging authentication issues"            │
└──────────────────┬──────────────────────────────────────┘
                   │ Pattern Detection
                   ▼
┌─────────────────────────────────────────────────────────┐
│  SEMANTIC MEMORY (SM)                                   │
│  Facts, rules, patterns extracted from episodes         │
│  "auth.py frequently has bugs"                         │
└──────────────────┬──────────────────────────────────────┘
                   │ Knowledge Graph (GraphRAG)
                   ▼
┌─────────────────────────────────────────────────────────┐
│  LONG-TERM MEMORY (LTM)                                 │
│  Consolidated knowledge, insights, wisdom               │
│  "Authentication module needs refactoring"              │
└─────────────────────────────────────────────────────────┘
```

## 1. Episodic Memory (EM)

### Purpose
Stores **specific events and experiences** in chronological order, similar to human autobiographical memory.

### Characteristics
- **Time-stamped**: Every memory has a precise timestamp
- **Contextual**: Includes full context of the event
- **High volume**: Can grow very large over time
- **Raw data**: Minimal processing, stores as-is

### Use Cases
- Recording user interactions
- Logging agent actions
- Tracking code changes
- Storing conversation history

### Example
```python
await client.store_memory(
    content="User reported authentication timeout at 3:15 PM",
    layer="episodic",
    tags=["bug-report", "auth", "timeout"],
    metadata={
        "user_id": "user_123",
        "severity": "high",
        "timestamp": "2025-01-15T15:15:00Z"
    }
)
```

### Retention
- Episodic memories can be archived or consolidated into semantic memory after a period
- Default retention: 30 days (configurable)
- Older episodes may be summarized to save space

## 2. Working Memory (WM)

### Purpose
Holds **currently active information** relevant to ongoing tasks, similar to human short-term memory.

### Characteristics
- **Small capacity**: Limited size (typically 5-10 items)
- **High relevance**: Only most pertinent information
- **Temporary**: Automatically cleared when task completes
- **Fast access**: Optimized for quick retrieval

### Use Cases
- Current conversation context
- Active task state
- Temporary variables
- Session data

### Example
```python
await client.store_memory(
    content="User is currently implementing OAuth2 authentication",
    layer="working",
    tags=["active-task", "auth", "oauth2"],
    metadata={
        "session_id": "sess_abc123",
        "task_id": "task_789"
    }
)
```

### Management
- Working memory is automatically pruned based on:
  - Recency (older items removed first)
  - Relevance scores
  - Session boundaries
- Can be explicitly cleared when task completes

## 3. Semantic Memory (SM)

### Purpose
Stores **facts, concepts, and patterns** extracted from episodic memories, similar to human general knowledge.

### Characteristics
- **Decontextualized**: Facts without specific time/place
- **Generalized**: Patterns across multiple episodes
- **Structured**: Organized by relationships
- **Compact**: More space-efficient than episodes

### Use Cases
- Domain knowledge
- Coding standards
- User preferences
- System rules
- Learned patterns

### Example
```python
await client.store_memory(
    content="User prefers TypeScript over JavaScript for new projects",
    layer="semantic",
    tags=["preference", "coding", "languages"],
    metadata={
        "confidence": 0.95,
        "derived_from": ["episode_123", "episode_456", "episode_789"]
    }
)
```

### Creation
Semantic memories are typically:
- Generated by the Reflection Engine from episodic memories
- Manually added for facts/rules
- Extracted from documentation
- Learned from repeated patterns

## 4. Long-Term Memory (LTM)

### Purpose
Stores **consolidated wisdom and high-level insights** that persist indefinitely.

### Characteristics
- **Highly refined**: Distilled from semantic memories
- **Abstract**: High-level concepts
- **Permanent**: Never automatically deleted
- **Valuable**: Represents core knowledge

### Use Cases
- Architectural decisions
- Best practices
- Lessons learned
- Strategic insights
- Core principles

### Example
```python
await client.store_memory(
    content="For this codebase, always validate API inputs using Pydantic models before processing",
    layer="ltm",
    tags=["best-practice", "security", "validation"],
    metadata={
        "importance": 0.98,
        "category": "security",
        "applies_to": "all_api_endpoints"
    }
)
```

### Curation
LTM should be carefully curated:
- Manual review recommended
- High importance threshold
- Regular updates to reflect changing best practices
- Can override older LTM entries

## Memory Flow

### Typical Flow Pattern

1. **Event Occurs** → Stored in **Episodic Memory**
2. **Reflection Engine** analyzes episodes → Creates **Semantic Memory**
3. **Active Task** → Relevant memories loaded into **Working Memory**
4. **Pattern Emerges** → Refined semantic memories → **Long-Term Memory**

### Example: Learning User Preferences

```
Day 1: User uses dark mode (EM)
Day 3: User switches to dark mode again (EM)
Day 7: User mentions preferring dark themes (EM)
        ↓ Reflection
       User prefers dark mode (SM)
        ↓ Confirmation over time
       Always default to dark mode for this user (LTM)
```

## Querying Across Layers

### Layer-Specific Query
```python
# Query only episodic memories
results = await client.query_memory(
    query="authentication bugs",
    layers=["episodic"],
    top_k=10
)
```

### Multi-Layer Query
```python
# Query across all layers (default)
results = await client.query_memory(
    query="what do we know about auth issues?",
    layers=["episodic", "semantic", "ltm"],
    top_k=20
)
```

### Layer Prioritization
By default, RAE prioritizes layers:
1. **Working Memory** - Most relevant to current task
2. **Long-Term Memory** - High-value insights
3. **Semantic Memory** - General facts
4. **Episodic Memory** - Specific events

## Best Practices

### When to Use Each Layer

| Layer | Use When |
|-------|----------|
| **Episodic** | Recording specific events, logging actions, tracking history |
| **Working** | Active task context, temporary data, current session |
| **Semantic** | Facts, preferences, patterns, rules |
| **LTM** | Critical insights, best practices, architectural decisions |

### Memory Design Guidelines

1. **Start with Episodic**: When in doubt, store in episodic layer
2. **Let Reflection Work**: Don't manually create semantic memories unless necessary
3. **Curate LTM**: Be selective about what goes into long-term memory
4. **Tag Consistently**: Use consistent tagging across layers
5. **Include Metadata**: Rich metadata improves retrieval

### Performance Considerations

- **Working Memory**: Fastest, always in cache
- **LTM**: Very fast, high priority in cache
- **Semantic**: Fast, frequently accessed
- **Episodic**: Slower, may require database query

## Memory Consolidation

RAE can automatically consolidate memories:

```python
# Consolidate old episodic memories into semantic
await client.consolidate_memories(
    min_age_days=7,
    source_layer="episodic",
    target_layer="semantic"
)
```

This:
- Analyzes similar episodic memories
- Extracts common patterns
- Creates semantic memory
- Archives old episodes

## Configuration

### Memory Retention
```env
# .env
MEMORY_RETENTION_DAYS=30  # How long to keep episodic memories
MEMORY_DECAY_RATE=0.99    # Importance decay rate
```

### Layer Limits
```python
# Per-tenant memory limits (Enterprise feature)
{
    "episodic": 100000,  # Max episodic memories
    "working": 50,       # Max working memory items
    "semantic": 10000,   # Max semantic facts
    "ltm": 1000          # Max long-term insights
}
```

## Advanced Topics

- [Reflection Engine](reflection.md) - How semantic/LTM memories are created
- [Memory Scoring](../advanced/scoring_heuristics.md) - How memories are ranked
- [Knowledge Graph](graphrag.md) - Relationships between memories
- [Memory Lifecycle](../guides/memory-lifecycle.md) - Aging and consolidation

---

**Next**: [Reflection Engine →](reflection.md)
