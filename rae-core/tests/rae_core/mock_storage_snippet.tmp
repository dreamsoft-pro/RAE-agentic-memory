            # Sort results
            reverse = order_direction.lower() == "desc"
            results.sort(key=lambda m: m.get(order_by, ""), reverse=reverse)  # type: ignore[arg-type,return-value]
            return results[offset : offset + limit]

    async def delete_memories_with_metadata_filter(
        self, tenant_id: str, agent_id: str, layer: str, metadata_filter: dict[str, Any]
    ) -> int:
        count = 0
        to_delete = []
        for mid, memory in self._memories.items():
            if (
                memory["tenant_id"] == tenant_id
                and memory["agent_id"] == agent_id
                and memory["layer"] == layer
            ):
                match = True
                for k, v in metadata_filter.items():
                    if memory.get("metadata", {}).get(k) != v:
                        match = False
                        break
                if match:
                    to_delete.append(mid)
                    count += 1
        for mid in to_delete:
            del self._memories[mid]
        return count

    async def delete_memories_below_importance(
        self, tenant_id: str, agent_id: str, layer: str, importance_threshold: float
    ) -> int:
        count = 0
        to_delete = []
        for mid, memory in self._memories.items():
            if (
                memory["tenant_id"] == tenant_id
                and memory["agent_id"] == agent_id
                and memory["layer"] == layer
                and memory.get("importance", 0) < importance_threshold
            ):
                to_delete.append(mid)
                count += 1
        for mid in to_delete:
            del self._memories[mid]
        return count

    async def count_memories(
        self, tenant_id: str, agent_id: str | None = None, layer: str | None = None
    ) -> int:
        count = 0
        for memory in self._memories.values():
            if (
                memory["tenant_id"] == tenant_id
                and (agent_id is None or memory["agent_id"] == agent_id)
                and (layer is None or memory["layer"] == layer)
            ):
                count += 1
        return count

    async def search_memories(
        self,
        query: str,
        tenant_id: str,
        agent_id: str,
        layer: str,
        limit: int = 10,
        filters: dict[str, Any] | None = None,
    ) -> list[dict[str, Any]]:
        results = []
        for memory in self._memories.values():
            if (
                memory["tenant_id"] == tenant_id
                and memory["agent_id"] == agent_id
                and memory["layer"] == layer
                and query.lower() in memory["content"].lower()
            ):
                results.append({"memory": memory.copy(), "score": 1.0})
        return results[:limit]

    async def delete_expired_memories(
        self, tenant_id: str, agent_id: str, layer: str
    ) -> int:
        return 0

    async def update_memory_access(self, memory_id: UUID, tenant_id: str) -> bool:
        memory = self._memories.get(memory_id)
        if memory and memory["tenant_id"] == tenant_id:
            memory["usage_count"] += 1
            memory["last_accessed_at"] = datetime.now(timezone.utc)
            return True
        return False

    async def update_memory_expiration(
        self, memory_id: UUID, tenant_id: str, expires_at: Any
    ) -> bool:
        memory = self._memories.get(memory_id)
        if memory and memory["tenant_id"] == tenant_id:
            memory["expires_at"] = expires_at
            return True
        return False

    async def get_metric_aggregate(
        self, tenant_id: str, metric: str, func: str, filters: dict[str, Any] | None = None
    ) -> float:
        return 0.0

    async def update_memory_access_batch(
        self, memory_ids: list[UUID], tenant_id: str
    ) -> bool:
        for mid in memory_ids:
            await self.update_memory_access(mid, tenant_id)
        return True

    async def adjust_importance(
        self, memory_id: UUID, delta: float, tenant_id: str
    ) -> float:
        memory = self._memories.get(memory_id)
        if memory and memory["tenant_id"] == tenant_id:
            memory["importance"] = max(0.0, min(1.0, memory.get("importance", 0.5) + delta))
            return memory["importance"]
        return 0.0

    async def save_embedding(
        self,
        memory_id: UUID,
        model_name: str,
        embedding: list[float],
        tenant_id: str,
        metadata: dict[str, Any] | None = None,
    ) -> bool:
        return True

    async def decay_importance(
        self, tenant_id: str, decay_rate: float, consider_access_stats: bool = False
    ) -> int:
        count = 0
        for memory in self._memories.values():
            if memory["tenant_id"] == tenant_id:
                memory["importance"] *= (1.0 - decay_rate)
                count += 1
        return count

    async def extract_entities(self, text: str) -> list[dict[str, Any]]:
        return [{"text": "MockEntity", "type": "MockType", "confidence": 0.9}]

    async def summarize(self, text: str, max_length: int = 200) -> str:
        return f"Mocked summary of: {text[:max_length]}"


@pytest.fixture(scope="function")
async def mock_memory_storage() -> MockMemoryStorage:
    """Provides a mocked IMemoryStorage instance."""
    return MockMemoryStorage()
