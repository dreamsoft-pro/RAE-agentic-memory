class MockMemoryStorage(IMemoryStorage):
    def __init__(self):
        self._memories: dict[UUID, dict[str, Any]] = {}
        self._lock = asyncio.Lock()  # To simulate async behavior

    async def store_memory(
        self,
        content: str,
        layer: str,
        tenant_id: str,
        agent_id: str,
        tags: list[str] | None = None,
        metadata: dict[str, Any] | None = None,
        embedding: list[float] | None = None,
        importance: float | None = None,
        expires_at: Any | None = None,
        memory_type: str = "text",
        project: str | None = None,
        session_id: str | None = None,
        source: str | None = None,
        strength: float = 1.0,
    ) -> UUID:
        async with self._lock:
            memory_id = uuid4()
            now = datetime.now(timezone.utc)
            memory = {
                "id": memory_id,
                "content": content,
                "layer": layer,
                "tenant_id": tenant_id,
                "agent_id": agent_id,
                "tags": tags or [],
                "metadata": metadata or {},
                "embedding": embedding,
                "importance": importance or 0.5,
                "created_at": now,
                "last_accessed_at": now,
                "expires_at": expires_at,
                "usage_count": 0,
                "memory_type": memory_type,
                "project": project,
                "session_id": session_id,
                "source": source,
                "strength": strength,
            }
            self._memories[memory_id] = memory
            return memory_id

    async def get_memory(
        self, memory_id: UUID, tenant_id: str
    ) -> dict[str, Any] | None:
        async with self._lock:
            memory = self._memories.get(memory_id)
            if memory and memory["tenant_id"] == tenant_id:
                return memory.copy()
            return None

    async def update_memory(
        self, memory_id: UUID, tenant_id: str, updates: dict[str, Any]
    ) -> bool:
        async with self._lock:
            memory = self._memories.get(memory_id)
            if memory and memory["tenant_id"] == tenant_id:
                memory.update(updates)
                return True
            return False

    async def delete_memory(self, memory_id: UUID, tenant_id: str) -> bool:
        async with self._lock:
            memory = self._memories.get(memory_id)
            if memory and memory["tenant_id"] == tenant_id:
                del self._memories[memory_id]
                return True
            return False

    async def list_memories(
        self,
        tenant_id: str,
        agent_id: str | None = None,
        layer: str | None = None,
        tags: list[str] | None = None,
        filters: dict[str, Any] | None = None,
        limit: int = 100,
        offset: int = 0,
        order_by: str = "created_at",
        order_direction: str = "desc",
    ) -> list[dict[str, Any]]:
        async with self._lock:
            results = []
            for memory in self._memories.values():
                if (
                    memory["tenant_id"] == tenant_id
                    and (agent_id is None or memory["agent_id"] == agent_id)
                    and (layer is None or memory["layer"] == layer)
                    and (tags is None or any(tag in memory["tags"] for tag in tags))
                ):
                    # Apply additional filters
                    match = True
                    if filters:
                        for key, value in filters.items():
                            if key.startswith("metadata."):
                                meta_key = key.split(".", 1)[1]
                                if memory.get("metadata", {}).get(meta_key) != value:
                                    match = False

                    if match:
                        results.append(memory.copy())

            # Sort results
            reverse = order_direction.lower() == "desc"
            results.sort(key=lambda m: m.get(order_by, ""), reverse=reverse)  # type: ignore[arg-type,return-value]
            return results[offset : offset + limit]

    async def delete_memories_with_metadata_filter(
        self, tenant_id: str, agent_id: str, layer: str, metadata_filter: dict[str, Any]
    ) -> int:
        count = 0
        to_delete = []
        for mid, memory in self._memories.items():
            if (
                memory["tenant_id"] == tenant_id
                and memory["agent_id"] == agent_id
                and memory["layer"] == layer
            ):
                match = True
                for k, v in metadata_filter.items():
                    if memory.get("metadata", {}).get(k) != v:
                        match = False
                        break
                if match:
                    to_delete.append(mid)
                    count += 1
        for mid in to_delete:
            del self._memories[mid]
        return count

    async def delete_memories_below_importance(
        self, tenant_id: str, agent_id: str, layer: str, importance_threshold: float
    ) -> int:
        count = 0
        to_delete = []
        for mid, memory in self._memories.items():
            if (
                memory["tenant_id"] == tenant_id
                and memory["agent_id"] == agent_id
                and memory["layer"] == layer
                and memory.get("importance", 0) < importance_threshold
            ):
                to_delete.append(mid)
                count += 1
        for mid in to_delete:
            del self._memories[mid]
        return count

    async def count_memories(
        self, tenant_id: str, agent_id: str | None = None, layer: str | None = None
    ) -> int:
        count = 0
        for memory in self._memories.values():
            if (
                memory["tenant_id"] == tenant_id
                and (agent_id is None or memory["agent_id"] == agent_id)
                and (layer is None or memory["layer"] == layer)
            ):
                count += 1
        return count

    async def search_memories(
        self,
        query: str,
        tenant_id: str,
        agent_id: str,
        layer: str,
        limit: int = 10,
        filters: dict[str, Any] | None = None,
    ) -> list[dict[str, Any]]:
        results = []
        for memory in self._memories.values():
            if (
                memory["tenant_id"] == tenant_id
                and memory["agent_id"] == agent_id
                and memory["layer"] == layer
                and query.lower() in memory["content"].lower()
            ):
                results.append({"memory": memory.copy(), "score": 1.0})
        return results[:limit]

    async def delete_expired_memories(
        self, tenant_id: str, agent_id: str, layer: str
    ) -> int:
        return 0

    async def update_memory_access(self, memory_id: UUID, tenant_id: str) -> bool:
        memory = self._memories.get(memory_id)
        if memory and memory["tenant_id"] == tenant_id:
            memory["usage_count"] += 1
            memory["last_accessed_at"] = datetime.now(timezone.utc)
            return True
        return False

    async def update_memory_expiration(
        self, memory_id: UUID, tenant_id: str, expires_at: Any
    ) -> bool:
        memory = self._memories.get(memory_id)
        if memory and memory["tenant_id"] == tenant_id:
            memory["expires_at"] = expires_at
            return True
        return False

    async def get_metric_aggregate(
        self, tenant_id: str, metric: str, func: str, filters: dict[str, Any] | None = None
    ) -> float:
        return 0.0

    async def update_memory_access_batch(
        self, memory_ids: list[UUID], tenant_id: str
    ) -> bool:
        for mid in memory_ids:
            await self.update_memory_access(mid, tenant_id)
        return True

    async def adjust_importance(
        self, memory_id: UUID, delta: float, tenant_id: str
    ) -> float:
        memory = self._memories.get(memory_id)
        if memory and memory["tenant_id"] == tenant_id:
            memory["importance"] = max(0.0, min(1.0, memory.get("importance", 0.5) + delta))
            return memory["importance"]
        return 0.0

    async def save_embedding(
        self,
        memory_id: UUID,
        model_name: str,
        embedding: list[float],
        tenant_id: str,
        metadata: dict[str, Any] | None = None,
    ) -> bool:
        return True

    async def decay_importance(
        self, tenant_id: str, decay_rate: float, consider_access_stats: bool = False
    ) -> int:
        count = 0
        for memory in self._memories.values():
            if memory["tenant_id"] == tenant_id:
                memory["importance"] *= (1.0 - decay_rate)
                count += 1
        return count

    async def extract_entities(self, text: str) -> list[dict[str, Any]]:
        return [{"text": "MockEntity", "type": "MockType", "confidence": 0.9}]

    async def summarize(self, text: str, max_length: int = 200) -> str:
        return f"Mocked summary of: {text[:max_length]}"
