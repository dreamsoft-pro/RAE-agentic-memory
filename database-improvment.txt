# TASK: Implement Memory Contract Validation at Startup (RAE)

## Context
RAE uses persistent memory (Postgres + vector DBs + telemetry storage).
Currently the system relies on:
- migrations generated over time
- implicit assumptions about database state

This is NOT sufficient.

We need an explicit, runtime-safe mechanism that:
- validates the actual database structure against an expected contract
- fails fast if memory is inconsistent
- does NOT silently auto-fix or guess

This task is about **Memory Safety at Startup**, not about adding new features.

---

## Goal (Single Sentence)
Implement a **Memory Contract Validation mechanism** that runs at RAE startup and verifies that the database schema exactly matches the expected structure.

---

## High-Level Requirements (Must Follow)

### 1. No Silent Auto-Migrations
- The system MUST NOT modify the database automatically in default mode.
- Validation and migration are separate concerns.

### 2. Fail Fast
- If the schema is invalid or incomplete:
  - RAE MUST refuse to start
  - A clear error message MUST be produced
  - A structured report of differences MUST be available

### 3. Explicit Modes Only
The behavior MUST be controlled by an environment variable:

```env
RAE_DB_MODE=validate   # default
RAE_DB_MODE=init       # initialize empty database
RAE_DB_MODE=migrate   # apply migrations explicitly

    validate → only check, never modify

    init → allowed only if DB is empty

    migrate → apply versioned migrations intentionally

Expected Architecture
A. Schema Contract Definition

Introduce a declarative schema contract (code or structured definition) describing:

    tables

    columns

    data types

    nullability

    constraints (PK, FK, UNIQUE)

    indexes (including vector / time-series where applicable)

This contract represents:

    "The minimum correct memory structure required for this RAE version."

B. Runtime Schema Introspection

At startup, RAE MUST:

    Connect to the database

    Introspect actual schema (information_schema / pg_catalog)

    Compare actual state with expected contract

C. Validation Result

The validation MUST detect:

    missing tables

    extra tables (optional: warn)

    missing columns

    type mismatches

    missing constraints

    missing critical indexes

    schema version mismatch

Result MUST be:

    machine-readable (structured object)

    human-readable (log / report)

D. Schema Metadata Table (Required)

Add (or use) a single control table, e.g.:

rae_schema_meta (
  schema_name TEXT PRIMARY KEY,
  version TEXT NOT NULL,
  checksum TEXT NOT NULL,
  applied_at TIMESTAMP NOT NULL,
  rae_core_version TEXT NOT NULL
)

Purpose:

    detect drift

    track applied schema version

    enable auditability

Startup Flow (Must Be Implemented)

    RAE starts

    Reads RAE_DB_MODE

    Connects to DB

    Loads expected schema contract

    Introspects actual DB schema

    Compares expected vs actual

    Decision:

        OK → continue startup

        NOT OK → stop startup + error

This flow MUST run automatically on every startup.
Docker / Compose Considerations

    Database healthcheck ≠ schema correctness

    RAE must NOT rely solely on depends_on: service_healthy

    Validation must happen inside the RAE process

Telemetry & Logging

    Validation outcome MUST be logged

    Schema drift MUST be visible in telemetry (if enabled)

    Errors must clearly state:

        what is missing

        what is incompatible

        what version is expected

Non-Goals (Explicitly Out of Scope)

    No UI

    No auto-healing

    No silent fixes

    No best-effort startup

Correctness > availability.
Definition of Done

This task is complete when:

    RAE refuses to start on invalid or partial schema

    RAE starts reliably on valid schema

    Schema version and drift are detectable

    The mechanism is deterministic and repeatable

    The solution is database-agnostic at the abstraction level (Postgres now, extensible later)

Guiding Principle

    Migrations describe how to reach a state.
    Validation proves that the system is already in that state.

This principle MUST be preserved.

## Critical Architectural Constraint (Must Not Be Violated)

RAE is backend-agnostic not only for databases, but also for:
- cache backends
- storage / artifact backends

The Memory Contract validation mechanism MUST:
- operate on an abstract memory contract
- NOT assume SQL, tables, or schemas in core logic
- be implemented via backend adapters

Validation MUST be supported for:
- persistent databases
- cache layers (Redis, in-memory, etc.)
- storage layers (filesystem, object storage)

Each backend type must validate its ability to fulfill the memory contract
using backend-specific introspection, without leaking implementation details
into RAE-core.
