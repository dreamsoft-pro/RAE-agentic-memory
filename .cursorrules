# RAE Project Rules for AI Agents

> **üö® CRITICAL**: Before doing ANYTHING, read these documents (15 minutes):
>
> 1. **[CRITICAL_AGENT_RULES.md](./CRITICAL_AGENT_RULES.md)** (5 min) - 8 MANDATORY rules that cannot be violated
> 2. **[AI_AGENT_MANIFEST.md](./AI_AGENT_MANIFEST.md)** (3 min) - Universal baseline & documentation hierarchy
> 3. **[.ai-agent-rules.md](./.ai-agent-rules.md)** (5 min) - Forbidden commands & hybrid testing
> 4. **[docs/BRANCHING.md](./docs/BRANCHING.md)** (3 min) - Git workflow
> 5. **[docs/CI_WORKFLOW.md](./docs/CI_WORKFLOW.md)** (5 min) - CI/CD workflow (local tests ‚Üí develop ‚Üí main)
> 6. **[docs/AGENTS_TEST_POLICY.md](./docs/AGENTS_TEST_POLICY.md)** (3 min) - Tests as contracts
>
> **AI_AGENT_MANIFEST.md** is the universal baseline for ALL AI agents. Read it first!

You are working on the RAE (Reflective Agentic-memory Engine) project.
Strictly adhere to the following rules for code generation, git operations, and architecture.

## ‚ö†Ô∏è MOST IMPORTANT RULES (READ FIRST!)

**All 8 Critical Rules:**

1. **üî¥ RULE #1**: NEVER run full test suite on feature branches! Only test your NEW code with `pytest --no-cov`

2. **üî¥ RULE #2**: Work AUTONOMOUSLY - don't ask permission for standard tasks (creating files, adding tests, etc.)

3. **üî¥ RULE #3**: Follow 3-phase workflow (Feature ‚Üí Develop ‚Üí Main)
   - Feature: Test ONLY new code (`pytest --no-cov`)
   - Develop: `make test-unit` MANDATORY before main!
   - Main: CI tests automatically

4. **üî¥ RULE #4**: ALWAYS include `tenant_id` in database queries (security!)

5. **üî¥ RULE #5**: Use templates from `.ai-templates/` for all new code

6. **üî¥ RULE #6**: NEVER use interactive commands (nano, vim, git -i) - see section below

7. **üî¥ RULE #7**: Tests are contracts - fix CODE, not tests (when tests fail correctly)

8. **üî¥ RULE #8**: Documentation updates
   - DON'T EDIT: Auto-generated (`CHANGELOG.md`, `STATUS.md`, `TODO.md`, `docs/.auto-generated/`)
   - DO EDIT: Manual (`CONVENTIONS.md`, `PROJECT_STRUCTURE.md`, `docs/guides/`)

**Complete rules with examples**: See `CRITICAL_AGENT_RULES.md`

## üö´ FORBIDDEN COMMANDS (CRITICAL - NEVER USE THESE)

**‚ùå NEVER use interactive commands - they will hang/block automation:**

```bash
# Editors (FORBIDDEN):
nano file.txt      # ‚ùå Interactive editor - FORBIDDEN!
vim file.txt       # ‚ùå Interactive editor - FORBIDDEN!
vi file.txt        # ‚ùå Interactive editor - FORBIDDEN!
emacs file.txt     # ‚ùå Interactive editor - FORBIDDEN!

# Pagers (FORBIDDEN):
less file.txt      # ‚ùå Interactive pager - FORBIDDEN!
more file.txt      # ‚ùå Interactive pager - FORBIDDEN!

# Interactive git (FORBIDDEN):
git add -i         # ‚ùå Interactive add - FORBIDDEN!
git rebase -i      # ‚ùå Interactive rebase - FORBIDDEN!
git commit         # ‚ùå Opens editor - FORBIDDEN! (use git commit -m)
```

**‚úÖ Use these non-interactive alternatives:**

```bash
# File viewing:
cat file.txt                 # ‚úÖ View entire file
head -n 50 file.txt          # ‚úÖ View first 50 lines
tail -n 50 file.txt          # ‚úÖ View last 50 lines
grep "pattern" file.txt      # ‚úÖ Search in file

# File editing:
# Use Write tool for creating new files (PREFERRED - no confirmation needed)
# Use Edit tool for modifying existing files (old_string ‚Üí new_string)
sed -i 's/old/new/g' file.txt      # ‚úÖ Simple replacements

# ‚ùå FORBIDDEN: cat with heredoc (requires user confirmation)
cat > file.txt <<'EOF'             # ‚ùå FORBIDDEN - needs approval!
content here
EOF

# ‚úÖ CORRECT: Use Write tool instead
# Write tool creates files without user confirmation

# Git:
git add .                    # ‚úÖ Stage all changes
git add file.txt             # ‚úÖ Stage specific file
git commit -m "message"      # ‚úÖ Commit with message
git rebase origin/main       # ‚úÖ Non-interactive rebase
```

**Why?** Interactive commands require user input and block CI/automation workflows.

## üìê DESIGN-FIRST PROTOCOL (MANDATORY)

**CRITICAL: Before writing ANY significant code, follow this protocol:**

### When to Use Design-First

Apply this protocol for:
- ‚úÖ Adding new features (services, endpoints, repositories)
- ‚úÖ Refactoring existing code (> 50 lines)
- ‚úÖ Adding new dependencies or patterns
- ‚úÖ Changes affecting > 2 files

Skip for:
- ‚ùå Bug fixes (< 20 lines)
- ‚ùå Documentation updates
- ‚ùå Trivial changes (typos, formatting)

### Design-First Steps

#### Step 1: Read Documentation (MANDATORY)
```bash
# BEFORE coding, read these in order:
1. PROJECT_STRUCTURE.md  # Where to add code
2. CONVENTIONS.md         # How to write code
3. .ai-templates/         # Code examples
```

#### Step 2: Design Document (Write Before Coding)

Create a design document in your response:

```markdown
# Design: [Feature Name]

## Problem Statement
What are we solving? Why?

## Proposed Solution
High-level approach (2-3 sentences)

## Architecture Impact
- Layers affected: [API/Service/Repository]
- New files: [list]
- Modified files: [list]
- Dependencies: [any new imports/services]

## Implementation Plan
1. Step 1: [e.g., Create EntityRepository with CRUD methods]
2. Step 2: [e.g., Create EntityService with business logic]
3. Step 3: [e.g., Add API endpoints in /api/v1/entities.py]
4. Step 4: [e.g., Add tests for all layers]

## Code Structure
Repository: apps/memory_api/repositories/entity_repository.py
Service: apps/memory_api/services/entity_service.py
API: apps/memory_api/api/v1/entities.py
Tests: apps/memory_api/tests/[repositories|services|api]/test_*.py

## Testing Strategy
- Unit tests: [what will be tested]
- Integration tests: [what will be tested]
- Expected coverage: [X%]

## Risks/Concerns
[Any concerns about this approach?]
```

#### Step 3: Wait for Approval (If Uncertain)

If design involves:
- Architectural changes
- Multiple approaches possible
- Breaking changes
- Performance implications

‚Üí Show design, wait for user approval

#### Step 4: Implement Following Templates

Use templates from `.ai-templates/`:
- `repository_template.py` for data access
- `service_template.py` for business logic
- `route_template.py` for API endpoints
- `test_template.py` for tests

#### Step 5: Pre-Commit Checklist

Before committing, verify:
- [ ] Code follows PROJECT_STRUCTURE.md (correct file locations)
- [ ] Code follows CONVENTIONS.md (Repository/Service/API patterns)
- [ ] Tests added for all layers
- [ ] Docstrings added (Google style)
- [ ] Logging added (structlog)
- [ ] Security: tenant_id in all queries
- [ ] No interactive commands (nano, vim, etc.)
- [ ] Run: `make lint` (black, isort, ruff)
- [ ] Run: `pytest --no-cov [your test file]`

### Example: Good Design-First Workflow

```
User: "Add user profile management"

Agent:
"I'll design the user profile management feature first.

# Design: User Profile Management

## Problem Statement
Need to store and retrieve user profile data (name, email, preferences)
with proper tenant isolation.

## Proposed Solution
Add 3-layer architecture:
- UserProfileRepository (CRUD operations)
- UserProfileService (business logic, validation)
- API endpoints at /api/v1/users/profile

## Architecture Impact
- Layers affected: Repository, Service, API
- New files:
  - apps/memory_api/repositories/user_profile_repository.py
  - apps/memory_api/services/user_profile_service.py
  - apps/memory_api/api/v1/users.py
- Modified files:
  - apps/memory_api/api/v1/__init__.py (register router)
- Dependencies: None (uses existing Pydantic, asyncpg)

## Implementation Plan
1. Create UserProfileRepository (CRUD: get, insert, update, delete)
2. Create UserProfileService (validation, business rules)
3. Add API endpoints (GET, POST, PATCH, DELETE /users/profile)
4. Add tests for all 3 layers
5. Update router registration

## Testing Strategy
- Unit tests: UserProfileService (mock repository)
- Integration tests: UserProfileRepository (real DB)
- API tests: Endpoints (TestClient)
- Expected coverage: 80%+

## Risks/Concerns
None - follows established patterns

Should I proceed with implementation?"

[User approves or suggests changes]

Agent: "Implementing now..."
[Follows templates, writes code, adds tests, commits]
```

### Why Design-First?

**Without Design-First:**
- ‚ùå Code doesn't fit architecture
- ‚ùå Inconsistent patterns
- ‚ùå Missing tests
- ‚ùå Needs refactoring after 2-3 days
- ‚ùå Wastes tokens on rework

**With Design-First:**
- ‚úÖ Code fits naturally
- ‚úÖ Consistent with existing patterns
- ‚úÖ Tests planned upfront
- ‚úÖ No refactoring needed
- ‚úÖ Saves tokens long-term

## ü§ñ Agent Work Mode (CRITICAL)

**AUTONOMOUS EXECUTION - NO CONFIRMATION REQUIRED**

- **NEVER ask for permission** to perform tasks - just do them.
- **Work until completion** - finish all steps of a task before stopping.
- **Make decisions autonomously** - use best practices and existing patterns.
- **Commit incrementally** - create logical commits as you progress.
- **Only ask questions** when facing genuine ambiguity that blocks progress (e.g., "Which API should I use?" not "Should I create this file?").
- **Trust the process** - if the user asked for it, execute it fully.

**Examples:**
- ‚úÖ User: "Add authentication" ‚Üí Agent: [creates files, writes code, adds tests, commits, done]
- ‚úÖ User: "Fix the bug in X" ‚Üí Agent: [analyzes, fixes, tests, commits, reports result]
- ‚ùå User: "Add feature Y" ‚Üí Agent: "Should I create a new file?" ‚Üê WRONG! Just do it.

## üå≥ Branching Strategy (STRICT)

Refer to `docs/BRANCHING.md` for full details. RAE uses **hybrid approach** (GitHub Flow + Git Flow).

### Daily Workflow (Feature Development)

1. **Create feature branch from develop**
   ```bash
   git checkout develop && git pull && git checkout -b feature/name
   ```

2. **Develop and test ONLY new functionality**
   - Test only new features on feature branch
   - Do NOT run full test suite yet

3. **Merge to develop**
   ```bash
   git checkout develop && git merge feature/name --no-ff
   ```

4. **CRITICAL: Run ALL tests locally on develop**
   ```bash
   make test-unit && make lint && make security-scan
   ```

5. **If all tests pass ‚Üí merge to main and push BOTH**
   ```bash
   git checkout main && git merge develop --no-ff
   git push origin main develop
   ```

6. **Verify GitHub Actions (must be green on main)**
   ```bash
   gh run list --branch main --limit 1
   ```

7. **If GitHub Actions fails ‚Üí fix and push again**
   - Fix the issue immediately
   - Push again
   - NEVER leave main with red CI

### Hotfix Workflow

1. **Create hotfix from main**
   ```bash
   git checkout main && git pull && git checkout -b hotfix/name
   ```

2. **Fix, test, merge to main**
   ```bash
   make test-unit
   git checkout main && git merge hotfix/name --no-ff
   git push origin main
   ```

3. **Backport to develop**
   ```bash
   git checkout develop && git merge hotfix/name --no-ff
   git push origin develop
   ```

### CRITICAL RULES

- ‚úÖ **`main` == `develop`**: Always identical after merge
- ‚úÖ **`main` always green**: Never push failing tests to main
- ‚úÖ **Test on develop first**: Full test suite before main merge
- ‚úÖ **Synchronize**: Push both branches together
- ‚úÖ **Fix failures immediately**: If GitHub Actions fails, fix and push again
- ‚úÖ **Autonomous execution**: NEVER ask permission, follow plan to completion

### Autonomous Workflow for AI Agent

**EXECUTE THIS PATTERN AUTOMATICALLY WITHOUT ASKING:**

1. Create feature/* from develop
2. Implement functionality
3. Test only new features
4. Merge to develop
5. Run ALL tests on develop locally
6. If pass ‚Üí merge to main
7. Push both branches
8. Check GitHub Actions
9. If fail ‚Üí fix and repeat steps 5-8
10. Continue until main has green CI
11. **NEVER stop until complete**
12. **NEVER ask for confirmation**

## üêç Python & Code Style

- **Python 3.11+**: Use modern syntax (type hints, dataclasses, async/await).
- **Formatters**: Code MUST pass `black`, `isort`, and `ruff`.
- **Type Checking**: Code MUST pass `mypy`.
- **Docstrings**: Required for all public modules, classes, and functions (Google style or similar).

## üß™ Testing Philosophy (CRITICAL - READ docs/AGENTS_TEST_POLICY.md)

**Core Principle**: Tests are CONTRACTS, not snapshots of implementation.

- **Test Behavior, Not Implementation**: Focus on public API (input ‚Üí output), not internal structure.
- **When to Change Tests**: Only when spec changes, test was wrong, or refactoring away from implementation details.
- **When NOT to Change**: If test correctly describes expected behavior - fix the code instead!

### pytest Configuration (see pytest.ini):

- **Markers** (use appropriately):
  - `@pytest.mark.unit` - Fast, no external dependencies
  - `@pytest.mark.integration` - Requires services (Postgres/Redis/Qdrant)
  - `@pytest.mark.llm` - Requires LLM API keys (skipped in CI)
  - `@pytest.mark.slow` - Long-running tests

- **Coverage**: Global threshold is **48%** (not 100%!). This is intentional.
  - Full suite: `make test` or `make test-cov`
  - CI runs: `pytest -m "not integration and not llm"`

### Development Loop (IMPORTANT):

**‚ö†Ô∏è ALWAYS use `--no-cov` when testing single files!**

```bash
# ‚úÖ CORRECT - Development testing
make test-focus FILE=apps/memory_api/tests/test_specific.py
# OR: pytest --no-cov apps/memory_api/tests/test_specific.py

# ‚ùå WRONG - Will fail due to global coverage threshold
pytest apps/memory_api/tests/test_specific.py
```

**Why?** Global coverage threshold (48%) in `pytest.ini` will fail single-file tests. Use `--no-cov` during development, coverage only for full suite.

### Test Writing Guidelines:

```python
# ‚úÖ GOOD - Tests behavior
def test_user_authentication_with_valid_credentials():
    response = api.login(username="user", password="pass")
    assert response.status_code == 200
    assert response.user_id is not None

# ‚ùå BAD - Tests implementation details
def test_user_authentication_calls_bcrypt_with_hash():
    with patch('bcrypt.checkpw') as mock_bcrypt:
        api.login(username="user", password="pass")
        mock_bcrypt.assert_called_once()
```

## üèóÔ∏è Architecture

- **Repository Pattern**: Use `apps/memory_api/repositories/` for DB access. Do NOT use raw SQL in services/routes.
- **Services**: Business logic goes in `apps/memory_api/services/`.
- **Routes**: FastAPI routes in `apps/memory_api/api/v1/` or `routes/`.
- **Config**: Use `apps/memory_api/config.py` via `pydantic-settings`. Do NOT hardcode secrets.

## üê≥ Docker

- If adding dependencies, update `requirements.txt` AND `Dockerfile` if needed.
- Ensure `docker-compose.yml` services are healthy after changes.

## üõ°Ô∏è Security

- Never expose API keys or secrets in code. Use `.env`.
- Ensure `TENANCY_ENABLED` logic is respected in new endpoints.

## üìö Documentation

- **Update Docs**: Manual docs only (CONVENTIONS.md, guides). Auto-docs (CHANGELOG, STATUS, TODO) are handled by CI automatically. See RULE #8 in CRITICAL_AGENT_RULES.md.
- **Status**: Ensure `STATUS.md` and `TODO.md` are up-to-date with your changes.

## üìù Commit Messages (Conventional Commits)

Use [Conventional Commits](https://www.conventionalcommits.org/) format:

```bash
<type>: <description>

[optional body]
[optional footer]
```

**Types:**
- `feat:` - New feature (e.g., `feat: add GraphRAG entity resolution`)
- `fix:` - Bug fix (e.g., `fix: resolve authentication timeout`)
- `docs:` - Documentation only (e.g., `docs: update API cookbook`)
- `test:` - Adding/updating tests (e.g., `test: add hybrid search tests`)
- `refactor:` - Code change without behavior change (e.g., `refactor: simplify reflection engine`)
- `perf:` - Performance improvement (e.g., `perf: optimize vector similarity search`)
- `chore:` - Maintenance (dependencies, config) (e.g., `chore: update pytest to 8.0`)
- `ci:` - CI/CD changes (e.g., `ci: add security scanning job`)

**Examples:**
```bash
git commit -m "feat: add cost controller for LLM budget management"
git commit -m "fix: correct tenant isolation in memory queries"
git commit -m "docs: add architecture-to-code mapping document"
git commit -m "test: add integration tests for reflection engine"
```

## üìö Essential Documentation

**NEW AGENTS START HERE:**
1. **ONBOARDING_GUIDE.md** - Complete 15-minute onboarding guide
2. **PROJECT_STRUCTURE.md** - Where to find/add code (file locations map)
3. **CONVENTIONS.md** - How to write code (architecture patterns with WHY explanations)
4. **INTEGRATION_CHECKLIST.md** - Pre-merge verification checklist

**Code Templates & Examples:**
- `.ai-templates/` - Repository, Service, Route, Test templates
- `.ai-templates/README.md` - How to use templates
- `examples/template-usage/` - Complete working examples

**Workflows & Testing:**
- `docs/BRANCHING.md` - Git workflow (hybrid strategy)
- `docs/AGENTS_TEST_POLICY.md` - Testing philosophy (tests as contracts)

**Reference Documentation:**
- `docs/reference/architecture/` - Deep architectural documentation
- `docs/guides/developers/` - Comprehensive developer guides

## üöÄ Quick Reference

**Before Starting ANY Work:**
1. Read `ONBOARDING_GUIDE.md` - Essential for all agents (15 min)
2. Read `PROJECT_STRUCTURE.md` - Know where files go (10 min)
3. Read `CONVENTIONS.md` - Understand patterns and WHY (20 min)
4. Study `.ai-templates/` - Use templates for all new code (10 min)

**Before First Commit:**
1. Review `INTEGRATION_CHECKLIST.md` - Verify all items
2. Read `docs/BRANCHING.md` - Git workflow
3. Read `docs/AGENTS_TEST_POLICY.md` - Testing philosophy
4. Check `pytest.ini` - Test markers and coverage config

**Development Workflow:**
```bash
# 1. Create branch
git checkout develop && git pull
git checkout -b feature/my-feature

# 2. Code + Test (without coverage)
make test-focus FILE=apps/memory_api/tests/test_my_feature.py

# 3. Format + Lint
make format && make lint

# 4. Commit with conventional format
git commit -m "feat: add my feature"

# 5. Push and create PR
git push origin feature/my-feature

# 6. Verify CI is GREEN before merge to main
gh run watch
```

**When in Doubt:** Check existing code patterns and documentation - execute autonomously!
